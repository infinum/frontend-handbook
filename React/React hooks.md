### React hooks

#### Using hook dependency arrays
Dependency arrays are a way to trigger re-firing of hooks only when it's dependencies change. React will keep the values generated by a hook stored in memory and then run it when a change of a dependency has occured. This applies to all hooks that can have dependencies.

```jsx
export const MyComponent: FC = ({ numberProp, stringProps }) => {
  useEffect(() => {
    // Runs only when `numberProps` or `stringProp` changes
  }, [numberProp, stringProp])
 
  // ...
}
```

For non-primitive values like objects, arrays and functions, React will do a reference comparison, instead of comparing them with their previous values.

```jsx
export const MyComponent: FC = ({ objectProp, arrayProp, functionProp }) => {
  useEffect(() => {
    // Runs only when `objectProp`, `arrayProp` or `functionProp` reference changes
  }, [objectProp, arrayProp, functionProp])

  // ...
}
```

Use an empty dependency array if you want a hook to fire only on inital render.

```jsx
export const MyComponent: FC = () => {
  useEffect(() => {
    // Runs only on initial render
  }, [])

  // ...
}
```

#### Avoid misusing hook dependencies

As all values and references are recreated on each render, if you use anything from inside the component scope, be sure to provide it as a dependency, even if you think that the dependency will never change.

For example, when a `useEffect` includes a prop or a value created inside the component's scope, you might be tempted to pass an empty array as a dependency to run it only on the initial render (trying to use it as you would `componentDidMount` in class components):

```jsx
// BAD
export const MyComponent: FC = () => {
  const [value, setValue] = useState();

  const updateState = () => {
    // Do something with `setValue`
  }

  useEffect(() => {
    updateState();
  }, [])

  // ...
}
```

```jsx
// BAD
export const MyComponent: FC = ({ handlerFunction }) => {
  useEffect(() => {
    handlerFunction();
  }, [])

  // ...
}
```

Or you might want to skip some of the dependencies, that you think will not change:

```jsx
// BAD
export const MyComponent: FC = () => {
  const [value, setValue] = useState(null);

  const doSomethingOnValueChange = () => {...}

  useEffect(() => {
    if (value) {
      doSomethingOnValueChange(numberProp);
    }
  }, [value]) // missing a dependency (`doSomethingOnValueChange`)

  // ...
}
```

While you might think that a value will never change, it is not garanteed, and React could use a stale value or reference, which might introduce bugs that are hard to trace in the future.

If you are doing this, there is good chance that you should rethink the implemenation and you actually need an alternative approach.

#### Derive new state from the previous state value, if possible

This way, you can avoid using state values as hook dependencies and causing additional rerenders.

```jsx
// BAD
export const Counter: FC = ({ incrementBy = 1 }) => {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(count + incrementBy), [
    incrementBy,
    count,
  ])

  // ...
}
```

```jsx
// GOOD
export const Counter: FC = ({ incrementBy = 1 }) => {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount((previousCount) => previousCount + incrementBy), [incrementBy])

  // ...
}
```

#### Prefer splitting individual state items, instead of using a single state object
While in some case, it will make more sense to group state items into a single object, if it's not neccessary, store them individually:

```jsx

```

#### Using lazy initialization when setting initial state with functions
If you are setting state with a function call, use lazy initialization and wrap it in an arrow function. This way you ensure that the function will be invoked only on first render:

```jsx
// BAD
const [id, setId] = useState(generateId());
```

```jsx
// GOOD
const [id, setId] = useState(() => generateId());
```

#### If the initial state is undefined, specify the state type:

```jsx
// BAD
const [text, setText] = useState();
```

```jsx
// GOOD
const [text, setText] = useState<string>();
```

#### Declare functions outside of the component, when they don't use anything from component scope (if you need to optimize rendering)

```jsx
const onButtonClick = (e: SyntheticEvent<HTMLButtonElement>) => {
  // This event handler is using only DOM's `event`
}

const Button: FC = () => {
  // ...
}
```

```jsx
const changeDocumentTitle = (title) => {
  document.title = title;
}

const App: FC = () => {
  // ...
}
```

#### Add event listeners in `useEffect`
If you need to add event listeners from component scope, you can do it inside `useEffect`. Don't forget to cleanup in the return statement, which will execute before component is unmounted.

```jsx
const App: FC = () => {
  useEffect(() => {
    document.addEventListener('fullscreenchange', onFullscreenChange);

    return document.removeEventListener('fullscreenchange', onFullscreenChange);
  }, [onFullscreenChange]);

  // ...
}
```

#### Wrap values derived from expensive calculations with `useMemo`

If you are using an expensive calculation to assign a value and it is causing slower performance, you can utilize `useMemo` to trigger that calculation only when necessary.

```jsx
// BAD
export const MyComponent: FC = ({ propA, propB }) => {
  const value = someExpensiveCalculation(propA, propB);

  // ...
}
```

```jsx
// GOOD
export const MyComponent: FC = ({ propA, propB }) => {
  const memoizedValue = useMemo(() => someExpensiveCalculation(propA, propB), [propA, propB]);

  // ...
}
```

#### Wrap non-primitive values with useMemo, if you are using them as depenencies or sending them as props

Since objects will be recreated on each render, they will also have a different reference every time - and `useEffect` will treat it as a changed dependency.

```jsx
export const MyComponent: FC = ({ propA, propB }) => {
  const nonMemoizedObject = {
    a: propA,
    b: propB,
  };

  useEffect(() => {
    /**
      On each render, `useEffect` is causing an additional rerender,
      since it's dependency is an object with a new reference every time.
    */
  }, [nonMemoizedObject])

  // ...
}
```

Assuming that `propA` and `propB` are primitive (or memoized, non-primitive) values, with `useMemo` you are ensuring that non-primitive references are retained throughout rerenders, until `propA` or `propB` have changed.

```jsx
export const MyComponent: FC = ({ propA, propB }) => {
  const memoizedObject = useMemo(() => {
    a: propA,
    b: propB,
  }, [propA, propB]);

  useEffect(() => {
    // Triggers rerenders only if object values have changed and `memoizedObject` is recreated
  }, [memoizedObject])
 
  // ...
}
```

You can apply the same way of thinking if you need to pass an non-primitive value as a prop to a component and you know it will cause a large subtree to rerender each time it changes:

```jsx
export const MyComponent: FC = ({ propA, propB }) => {
  const memoizedObject = useMemo(() => {
    a: propA,
    b: propB,
  }, [propA, propB]);

  const memoizedArray = useMemo(() => [propA, propB], [propA, propB])

  return (
    <ChildComponent objectProp={memoizedObject} arrayProp={memoizedArray}/>
  );
}
```

#### Do not use `useMemo` as a garantee that it will be a constant throughout component rerenders

If you need a value to stay the same throughout rerenders, you might think of `useMemo` as a nice way to "mimick" a constant. While it might seem that way, [it is not garanteed](https://reactjs.org/docs/hooks-reference.html#usememo) that it will not get garbage collected and that the value will not be recalculated.

```jsx
export const MyComponent: FC = () => {
  const id = useMemo(() => generateId(), []); // Not garanteed to be a constant

  // ...
}
```

Alternative approach, with lazy initialization:

```jsx
export const MyComponent: FC = () => {
  const [id, _] = useState(() => generateId()); // Initial value will stay the same throughout rerenders

  // ...
}
```

You can also store the value in a ref:
_Note: updating ref values will not trigger a rerender._

```jsx
export const MyComponent: FC = () => {
  const id = useRef(null);

  if (!id.current) {
    id.current = generateId();
  }

  // ...
}
```

If you want the component to rerender when the value is set:

```jsx
export const Component: FC = () => {
  const [id, setId] = useState();

  useEffect() => {
    if (!id) {
      setId(generateId());
    }
  }, [id]);

  // ...
}
```

#### Wrap functions with `useCallback` it they can cause large subtrees to rerender too often

While it is mostly unnecessary to wrap functions with `useCallback`, since the memoization process will usually be as expensive or more, it can be useful if functions' dependencies change often or if they are passed down to a large subtree of children.

```jsx
// In this case, memoization is probably not worth it, since it will not necessarily improve performance
export const MyButton: FC = () => {
  const onClick = useCallback((e: SyntheticEvent<HTMLButtonElement>) => {
    ...
  }, [])

  return (
    <Button onClick={onClick} />
  );
}
```

```jsx
// Here, memoization is probably useful, because `onClick` will stay the same if other state rerenders the component, and will not trigger a large subtree to rerender unnecessarily
export const MyList: FC = () => {
  // ...

  const onListItemClick = useCallback(() => {
    ...
  }, [...])

  return <LargeList onListItemClick={onListItemClick} />;
}
```

#### You don't have to avoid "inlining" non-expensive functions

React is good at optimizing, so if you prematurely decide to wrap a function inside a `useCallback` and declare it in the component scope, you might get slower performance in many cases, because how memoization can be expensive. In most cases, even if you improve performance, it will be insignificant in comparison to making your code less clean and harder to maintain.

```jsx
export const IncrementButton: FC = ({ onClick, stepSize }) => {
  /** 
  * You don't have to optimise (wrap in useCallback) because onClick and stepSize 
  * are the same on each render and React can optimise this by itself.
  **/
  return <button onClick={() => onClick(stepSize)}>Increment for {stepSize}</button>;
}

// GOOD
export const MyComponent: FC = () => {
  const [count, setCount] = useState(0);

  const increment = useCallback((stepSize) => { setState((previousCount) => previousCount + stepSize) }, []);

  return (
    <div>
      <div>{count}</div>
      <IncrementButton onClick={increment} stepSize={2} />
    </div>
  );
}
```

#### Before you use memoization

Have in mind that React is really good at optimizing rerenders by default.

You might get tempted to wrap values and functions with `useMemo` and `useCallback` all the time, but in many of these cases, you don't really need it, and you might even make your app performance and file size worse. These calculation's can be expensive and you could end up using more memory than you would without them and make you code more complicated to read and maintain.

If it's not obvious that memoization is necessary, profile your app performance without it first, using [React Devtools](https://github.com/facebook/react/tree/master/packages/react-devtools), and then optimize if necessary.

<figure class="image">
  <img src="/img/react-hooks/profiler.png" alt="React Devtools Profiler">
  <figcaption>
    <a href="https://github.com/facebook/react/tree/master/packages/react-devtools" target="_blank">
    React Devtools Profiler
    </a>
  </figcaption>
</figure>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">⚛️🛠 Prototype of a new Profiler feature, &quot;Scheduled by&quot;, enumerating which fibers triggered the current commit (which ones called set state).<br><br>Would this be useful? Could it be more useful? <a href="https://t.co/7AvVHB0wPY">pic.twitter.com/7AvVHB0wPY</a></p>&mdash; Brian Vaughn 🖤 (@brian_d_vaughn) <a href="https://twitter.com/brian_d_vaughn/status/1126950967201546240?ref_src=twsrc%5Etfw">May 10, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

If you want to dive deeper here are some useful articles:
1. [When to useMemo and useCallback
](https://kentcdodds.com/blog/usememo-and-usecallback)
1. [One simple trick to optimize React re-renders](https://kentcdodds.com/blog/optimize-react-re-renders)
1. [Profile a React App for Performance
](https://kentcdodds.com/blog/profile-a-react-app-for-performance)
1. [React Production Performance Monitoring](https://kentcdodds.com/blog/react-production-performance-monitoring)
