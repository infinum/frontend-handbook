### React hooks

React Hooks were introduced in version 16.8.0 as Function Component counterpart of Class Component Lifecycle.
For more information, see the official [React Hooks API Reference](https://reactjs.org/docs/hooks-reference.html).

#### Hooks flow
Before we start using hooks in React we need to understand the flow.

Here is a flow diagram that explains the new flow of a Hooks component.
![hooks-flow](https://raw.githubusercontent.com/donavon/hook-flow/master/hook-flow.png)

> Most important thing here is to notice how "Run Effects" phase is executed last!

Here is the code example that explains this flow.

```jsx
export const MyComponent: FC = ({ numberProp, stringProps }) => {
  // 1. Run Lazy initializers (e.g.() => 0)
  const [state, setState] = useState(() => 0); 

  const previousStateRef = useRef();

  useEffect(() => {
    // 3. Run effect
    previousStateRef.current = state;
  }); // no deps array, we want this to be called on every render!

  // 2. Render
  return (
    <>
      Prev: {previousStateRef.current ?? "undefined"}
      <br />
      Current: {state}
      <br />
      <button onClick={() => setState(1)}>Update</button>
    </>
  );
}
```

In the "Mount" phase you will see:
```
Prev: undefined
Current: 0
```
This is because `useEffect` after the first render and assigning values to `ref` does not trigger re-render but the value is populated and waiting for next update phase.

When button is clicked React will trigger `Update` phase and result will be:
```
Prev: 0
Current: 1
```

<iframe src="https://codesandbox.io/embed/react-flow-example-8x30c?fontsize=14&hidenavigation=1&theme=light"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="react-flow-example"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

#### Using hook dependency arrays
Dependency arrays are a way to trigger re-firing of hooks only when it's dependencies change. React will keep the values generated by a hook stored in memory and then run it when a change of a dependency has occured. This applies to all hooks that can have dependencies.

```jsx
export const MyComponent: FC = ({ numberProp, stringProps }) => {
  useEffect(() => {
    // Runs only when `numberProps` or `stringProp` changes
  }, [numberProp, stringProp])
 
  // ...
}
```

For non-primitive values like objects, arrays and functions, React will do a reference comparison, instead of comparing them with their previous values.

```jsx
export const MyComponent: FC = ({ objectProp, arrayProp, functionProp }) => {
  useEffect(() => {
    // Runs only when `objectProp`, `arrayProp` or `functionProp` reference changes
  }, [objectProp, arrayProp, functionProp])

  // ...
}
```

Use an empty dependency array if you want a hook to fire only on inital render.

```jsx
export const MyComponent: FC = () => {
  useEffect(() => {
    // Runs only on initial render
  }, [])

  // ...
}
```

#### Avoid misusing hook dependencies

As all values and references are recreated on each render, if you use anything from inside the component scope, be sure to provide it as a dependency, even if you think that the dependency will never change.

For example, when a `useEffect` includes a prop or a value created inside the component's scope, you might be tempted to pass an empty array as a dependency to run it only on the initial render (trying to use it as you would `componentDidMount` in class components):

```jsx
// BAD
export const MyComponent: FC = () => {
  const [value, setValue] = useState();

  const updateState = () => {
    // Do something with `setValue`
  }

  useEffect(() => {
    updateState();
  }, [])

  // ...
}
```

```jsx
// BAD
export const MyComponent: FC = ({ handlerFunction }) => {
  useEffect(() => {
    handlerFunction();
  }, [])

  // ...
}
```

Or you might want to skip some of the dependencies, that you think will not change:

```jsx
// BAD
export const MyComponent: FC = () => {
  const [value, setValue] = useState(null);

  const doSomethingOnValueChange = () => {...}

  useEffect(() => {
    if (value) {
      doSomethingOnValueChange(numberProp);
    }
  }, [value]) // missing a dependency (`doSomethingOnValueChange`)

  // ...
}
```

While you might think that a value will never change, it is not guaranteed, and React could use a stale value or reference, which might introduce bugs that are hard to trace in the future.

If you are doing this, there is good chance that you should rethink the implementation and you actually need an alternative approach.

#### Derive new state from the previous state value, if possible

This way, you can avoid using state values as hook dependencies and causing additional re-renders.

```jsx
// BAD
export const Counter: FC = ({ incrementBy = 1 }) => {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(count + incrementBy), [
    incrementBy,
    count,
  ])

  // ...
}
```

```jsx
// GOOD
export const Counter: FC = ({ incrementBy = 1 }) => {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount((previousCount) => previousCount + incrementBy), [incrementBy])

  // ...
}
```

#### Prefer splitting individual state items, instead of using a single state object
While in some case, it will make more sense to group state items into a single object, if it's not necessary, store them individually:

```jsx

```

#### Using lazy initialization when setting initial state with functions
If you are setting state with a function call, use lazy initialization and wrap it in an arrow function. This way you ensure that the function will be invoked only on first render:

```jsx
// BAD
const [id, setId] = useState(generateId());
```

```jsx
// GOOD
const [id, setId] = useState(() => generateId());
```

#### If the initial state is undefined, specify the state type:

```jsx
// BAD
const [text, setText] = useState();
```

```jsx
// GOOD
const [text, setText] = useState<string>();
```

#### Declare functions outside of the component, when they don't use anything from component scope (if you need to optimize rendering)

```jsx
const onButtonClick = (e: SyntheticEvent<HTMLButtonElement>) => {
  // This event handler is using only DOM's `event`
}

const Button: FC = () => {
  // ...
}
```

```jsx
const changeDocumentTitle = (title) => {
  document.title = title;
}

const App: FC = () => {
  // ...
}
```

#### Add event listeners in `useEffect`
If you need to add event listeners from component scope, you can do it inside `useEffect`. Don't forget to cleanup in the return statement, which will execute before component is unmounted.

```jsx
const App: FC = () => {
  useEffect(() => {
    document.addEventListener('fullscreenchange', onFullscreenChange);

    return document.removeEventListener('fullscreenchange', onFullscreenChange);
  }, [onFullscreenChange]);

  // ...
}
```

#### Wrap values derived from expensive calculations with `useMemo`

If you are using an expensive calculation to assign a value and it is causing slower performance, you can utilize `useMemo` to trigger that calculation only when necessary.

```jsx
// BAD
export const MyComponent: FC = ({ propA, propB }) => {
  const value = someExpensiveCalculation(propA, propB);

  // ...
}
```

```jsx
// GOOD
export const MyComponent: FC = ({ propA, propB }) => {
  const memoizedValue = useMemo(() => someExpensiveCalculation(propA, propB), [propA, propB]);

  // ...
}
```

#### Wrap non-primitive values with useMemo, if you are using them as dependencies or sending them as props

Since objects will be recreated on each render, they will also have a different reference every time - and `useEffect` will treat it as a changed dependency.

```jsx
export const MyComponent: FC = ({ propA, propB }) => {
  const nonMemoizedObject = {
    a: propA,
    b: propB,
  };

  useEffect(() => {
    /**
      On each render, `useEffect` is causing an additional re-render,
      since it's dependency is an object with a new reference every time.
    */
  }, [nonMemoizedObject])

  // ...
}
```

Assuming that `propA` and `propB` are primitive (or memoized, non-primitive) values, with `useMemo` you are ensuring that non-primitive references are retained throughout re-renders, until `propA` or `propB` have changed.

```jsx
export const MyComponent: FC = ({ propA, propB }) => {
  const memoizedObject = useMemo(() => {
    a: propA,
    b: propB,
  }, [propA, propB]);

  useEffect(() => {
    // Triggers re-renders only if object values have changed and `memoizedObject` is recreated
  }, [memoizedObject])
 
  // ...
}
```

You can apply the same way of thinking if you need to pass an non-primitive value as a prop to a component and you know it will cause a large subtree to re-render each time it changes:

```jsx
export const MyComponent: FC = ({ propA, propB }) => {
  const memoizedObject = useMemo(() => {
    a: propA,
    b: propB,
  }, [propA, propB]);

  const memoizedArray = useMemo(() => [propA, propB], [propA, propB])

  return (
    <ChildComponent objectProp={memoizedObject} arrayProp={memoizedArray}/>
  );
}
```

#### Do not use `useMemo` as a semantic guarantee that it will be a constant throughout component re-renders

If you need a value to stay the same throughout re-renders, you might think of `useMemo` as a nice way to "mimic" a constant. While it might seem that way, [it is not guaranteed](https://reactjs.org/docs/hooks-reference.html#usememo).

> **You may rely on useMemo as a performance optimization, not as a semantic guarantee.** In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo — and then add it to optimize performance.

```jsx
// BAD
export const MyComponent: FC = () => {
  const id = useMemo(() => generateId(), []); // Not guaranteed to be a constant

  // ...
}
```

Alternative approach, with lazy initialization:

```jsx
// GOOD
export const MyComponent: FC = () => {
  const [id, _] = useState(() => generateId()); // Initial value will stay the same throughout re-renders

  // ...
}
```

You can also store the value in a ref:
> Note: updating ref values will not trigger a re-render.

```jsx
export const MyComponent: FC = () => {
  const id = useRef(null);

  if (!id.current) {
    id.current = generateId();
  }

  // ...
}
```

If you still need to trigger update imperatively you can use `useUpdate`

```jsx
const updateReducer = (num: number): number => (num + 1) % 1_000_000;

export default function useUpdate(): () => void {
  const [, update] = useReducer(updateReducer, 0);

  return update;
}
```

#### Two-pass rendering

If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like `isClient`, which you can set to true in `useEffect`. This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration. Note that this approach will make your components slower because they have to render twice, so use it with caution.

Remember to be mindful of user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so if you render something different in the client-only pass, the transition can be jarring. However, if executed well, it may be beneficial to render a “shell” of the application on the server, and only show some of the extra widgets on the client. To learn how to do this without getting the markup mismatch issues, refer to the explanation in the previous paragraph

```jsx
const useIsClient = () => {
  const [isClient, setClient] = useState(false);

  useEffect(() => {
    setClient(true)
  }, []);

  return isClient;
}

export const Component: FC = () => {
  const isClient = useIsClient();

  return <div>{isClient ? 'Client' : 'Server'}</div>
}
```

#### Wrap functions with `useCallback` it they can cause large subtrees to re-render too often

While it is mostly unnecessary to wrap functions with `useCallback`, since the memoization process will usually be as expensive or more, it can be useful if functions' dependencies change often or if they are passed down to a large subtree of children.

```jsx
// In this case, memoization is probably not worth it, since it will not necessarily improve performance
export const MyButton: FC = () => {
  const onClick = useCallback((e: SyntheticEvent<HTMLButtonElement>) => {
    ...
  }, [])

  return (
    <Button onClick={onClick} />
  );
}
```

```jsx
// Here, memoization is probably useful, because `onClick` will stay the same if other state re-renders the component, and will not trigger a large subtree to re-render unnecessarily
export const MyList: FC = () => {
  // ...

  const onListItemClick = useCallback(() => {
    ...
  }, [...])

  return <LargeList onListItemClick={onListItemClick} />;
}
```

#### You don't have to avoid "inlining" non-expensive functions

React is good at optimizing, so if you prematurely decide to wrap a function inside a `useCallback`, often you will end up with slower performance. This is because memoization is expensive. In most cases, even if you improve performance, it will be an insignificant gain compared to simple and maintainable code you had before.

```jsx
export const StepButton: FC = ({ onClick, stepSize }) => {
  /** 
  * You don't have to optimise (wrap in useCallback) because onClick and stepSize 
  * are the same on each render and React can optimise this by itself.
  **/
  return <button onClick={() => onClick(stepSize)}>Increment for {stepSize}</button>;
}

// GOOD
export const MyComponent: FC = () => {
  const [count, setCount] = useState(0);

  const increment = useCallback((stepSize) => { setCount((previousCount) => previousCount + stepSize) }, []);

  return (
    <div>
      <div>Count {count}</div>
      <StepButton onClick={increment} stepSize={2} />
    </div>
  );
}
```

#### Hooks encapsulation

Common problem with hooks is that the components using them could go out of control and become unreadable and messy. 
That happens when you have multiple `useEffect` and `useCallback` in you FC component body, and that happens often if you are building real world product. To overcome this problem we can do the same thing as in class based component, split things in smaller chunks of logic and put them somewhere else, e.g. private methods of class component, custom hooks in Function components.

The Problem:

This is the continuation of previous section, but we will expand it with some additional requirements. 
We need to add input field in which we can input the thing we are counting, and add decrement and reset handlers for counter.

This is the previous code:
```jsx
export const MyComponent: FC = () => {
  const [count, setCount] = useState(0);

  const increment = useCallback((stepSize) => { setCount((previousCount) => previousCount + stepSize) }, []);

  return (
    <div>
      <div>Count {count}</div>
      <StepButton onClick={increment} stepSize={2} />
    </div>
  );
}
```

This is the updated code with additional features.
```jsx
export const MyComponent: FC = () => {
  const [count, setCount] = useState(0);
  const [inputState, setInputState] = useState('')

  const increment = useCallback((stepSize) => { setCount((previousCount) => previousCount + stepSize) }, []);
  const decrement = useCallback((stepSize) => { setCount((previousCount) => previousCount + stepSize) }, []);
  const reset = useCallback(() => { setCount(0) }, []);

  const handleInputChange = useCallback(e => {
    setInputState(e.target.value);
  }, []);

  return (
    <div>
      <div>
        <label htmlFor="entity">Entity</label>
        <input
          type="text"
          id="entity"
          onChange={handleInputChange}
          value={inputState}
        />
      </div>
      <div>Count {count}</div>
      <StepButton onClick={increment} stepSize={2} />
      <StepButton onClick={decrement} stepSize={-2} />
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

You can see that our component becomes messy and hard to understand. There is a lot of code in the body of the function which increase our [cognitive load](https://en.wikipedia.org/wiki/Cognitive_load). To fix this issue we can **encapsulate** our **elements of concern** into a separate _chunks of work_, e.g. custom hooks.

The Solution:

```jsx
const useCount = (initialState = 0) => {
  const [state, setState] = useState(() => initialState);

  const handlers = useMemo(
    () => ({
      increment: (stepSize = 1) => {
        setState(previousCount => previousCount + stepSize)
      },
      decrement: (stepSize = -1) => { 
        setState((previousCount) =>  previousCount + stepSize)
      },
      reset: () => {
        setState(0)
      }
    }),
    [initialState]
  );

  return [state, handlers];
}

const useInput = (initialState = '') => {
  const [state, setState] = useState(() => initialState);

  const handlers = useMemo(() => ({
    handleInputChange: (event) => {
      setState(event.target.value);
    }
  })), []);

  return [state, handlers]
}

export const MyComponent: FC = () => {
  const [count, { increment, decrement, reset }] = useCounter();
  const [inputState, { handleInputChange }] = useInput();

  return (
    <div>
      <div>
        <label htmlFor="entity">Entity</label>
        <input
          type="text"
          id="entity"
          onChange={handleInputChange}
          value={inputState}
        />
      </div>
      <div>Count {count}</div>
      <StepButton onClick={increment} stepSize={2} />
      <StepButton onClick={decrement} stepSize={-2} />
      <button onClick={reset}>Reset</button>
    </div>
  );
```

Useful links:
1. [useEncapsulation or Why Your React Components Should Only Use Custom Hooks](https://kyleshevlin.com/use-encapsulation)
1. [Encapsulation or the Primary Purpose of Functions](https://kyleshevlin.com/encapsulation)

#### Before you use memoization

Have in mind that React is really good at optimizing re-renders by default.

You might get tempted to wrap values and functions with `useMemo` and `useCallback` all the time, but in many of these cases, you don't really need it, and you might even make your app performance and file size worse. These calculations can be expensive and you could end up using more memory than you would without them and make you code more complicated to read and maintain.

If it's not obvious that memoization is necessary, profile your app performance without it first, using [React Devtools](https://github.com/facebook/react/tree/master/packages/react-devtools), and then optimize if necessary.

<figure class="image">
  <img src="/img/react-hooks/profiler.png" alt="React Devtools Profiler">
  <figcaption>
    <a href="https://github.com/facebook/react/tree/master/packages/react-devtools" target="_blank">
    React Devtools Profiler
    </a>
  </figcaption>
</figure>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">⚛️🛠 Prototype of a new Profiler feature, &quot;Scheduled by&quot;, enumerating which fibers triggered the current commit (which ones called set state).<br><br>Would this be useful? Could it be more useful? <a href="https://t.co/7AvVHB0wPY">pic.twitter.com/7AvVHB0wPY</a></p>&mdash; Brian Vaughn 🖤 (@brian_d_vaughn) <a href="https://twitter.com/brian_d_vaughn/status/1126950967201546240?ref_src=twsrc%5Etfw">May 10, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

If you want to dive deeper here are some useful articles:
1. [When to useMemo and useCallback
](https://kentcdodds.com/blog/usememo-and-usecallback)
1. [One simple trick to optimize React re-renders](https://kentcdodds.com/blog/optimize-react-re-renders)
1. [Profile a React App for Performance
](https://kentcdodds.com/blog/profile-a-react-app-for-performance)
1. [React Production Performance Monitoring](https://kentcdodds.com/blog/react-production-performance-monitoring)
